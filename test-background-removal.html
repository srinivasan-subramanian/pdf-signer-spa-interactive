<!DOCTYPE html>
<html>
<head>
    <title>Background Removal Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 20px; border: 1px solid #ccc; }
        .controls { margin: 10px 0; }
        .preview { display: flex; gap: 20px; align-items: flex-start; }
        .preview div { text-align: center; }
        canvas, img { border: 1px solid #333; }
        .checkerboard { 
            background: repeating-conic-gradient(#808080 0% 25%, transparent 0% 50%) 50% / 20px 20px;
        }
    </style>
</head>
<body>
    <h1>Background Removal Test</h1>
    
    <div class="test-section">
        <h3>Upload Test Image</h3>
        <input type="file" id="fileInput" accept="image/*">
        
        <div class="controls">
            <label>
                <input type="checkbox" id="removeBackground" checked> Remove background
            </label>
        </div>
        
        <div class="controls">
            <label>Threshold: <span id="thresholdValue">230</span></label>
            <input type="range" id="threshold" min="100" max="250" value="230">
        </div>
        
        <button onclick="processImage()">Process Image</button>
        
        <div class="preview">
            <div>
                <h4>Original</h4>
                <img id="original" style="max-width: 300px;">
            </div>
            <div>
                <h4>Processed</h4>
                <div class="checkerboard" style="display: inline-block; padding: 5px;">
                    <img id="processed" style="max-width: 300px;">
                </div>
            </div>
        </div>
        
        <div id="debug" style="margin-top: 20px; font-family: monospace; font-size: 12px;"></div>
    </div>

    <script>
        let currentImageData = null;
        
        // Background removal function (copied from SignaturePanel)
        function processBackground(imageDataUrl, shouldRemove, threshold) {
            return new Promise((resolve, reject) => {
                if (!shouldRemove) {
                    resolve(imageDataUrl);
                    return;
                }
                
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let pixelsChanged = 0;
                    let totalPixels = data.length / 4;
                    
                    // Analyze edge pixels to detect background color
                    const edgePixels = [];
                    
                    // Sample edges to find dominant background color
                    for (let x = 0; x < canvas.width; x += 4) {
                        const topIdx = x * 4;
                        const bottomIdx = ((canvas.height - 1) * canvas.width + x) * 4;
                        edgePixels.push({r: data[topIdx], g: data[topIdx + 1], b: data[topIdx + 2]});
                        edgePixels.push({r: data[bottomIdx], g: data[bottomIdx + 1], b: data[bottomIdx + 2]});
                    }
                    
                    for (let y = 0; y < canvas.height; y += 4) {
                        const leftIdx = (y * canvas.width) * 4;
                        const rightIdx = (y * canvas.width + canvas.width - 1) * 4;
                        edgePixels.push({r: data[leftIdx], g: data[leftIdx + 1], b: data[leftIdx + 2]});
                        edgePixels.push({r: data[rightIdx], g: data[rightIdx + 1], b: data[rightIdx + 2]});
                    }
                    
                    // Calculate average background color
                    let dominantBgColor = {r: 255, g: 255, b: 255};
                    if (edgePixels.length > 0) {
                        const avgColor = edgePixels.reduce(
                            (acc, pixel) => ({
                                r: acc.r + pixel.r,
                                g: acc.g + pixel.g,
                                b: acc.b + pixel.b
                            }),
                            {r: 0, g: 0, b: 0}
                        );
                        dominantBgColor = {
                            r: Math.round(avgColor.r / edgePixels.length),
                            g: Math.round(avgColor.g / edgePixels.length),
                            b: Math.round(avgColor.b / edgePixels.length)
                        };
                    }
                    
                    console.log('Detected background color:', dominantBgColor);
                    
                    // Method 1: Remove pixels similar to detected background
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1]; 
                        const b = data[i + 2];
                        const originalAlpha = data[i + 3];
                        
                        const colorDistance = Math.sqrt(
                            (r - dominantBgColor.r) ** 2 + 
                            (g - dominantBgColor.g) ** 2 + 
                            (b - dominantBgColor.b) ** 2
                        );
                        
                        const maxDistance = (255 - threshold) * 2;
                        if (colorDistance < maxDistance) {
                            data[i + 3] = 0;
                            if (originalAlpha > 0) pixelsChanged++;
                        }
                    }
                    
                    // Method 2: Adaptive brightness-based removal
                    const bgBrightness = 0.299 * dominantBgColor.r + 0.587 * dominantBgColor.g + 0.114 * dominantBgColor.b;
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 0) continue;
                        
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const originalAlpha = data[i + 3];
                        
                        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                        const adaptiveThreshold = Math.max(threshold, bgBrightness - 20);
                        
                        if (brightness > adaptiveThreshold) {
                            const isNeutral = Math.abs(r - g) < 40 && Math.abs(g - b) < 40 && Math.abs(r - b) < 40;
                            if (isNeutral) {
                                data[i + 3] = 0;
                                if (originalAlpha > 0) pixelsChanged++;
                            }
                        }
                    }
                    
                    // Method 3: Edge-aware processing
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = (y * width + x) * 4;
                            
                            if (data[idx + 3] === 0) continue; // Skip already transparent
                            
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                            const originalAlpha = data[idx + 3];
                            
                            if (brightness > threshold - 20) {
                                // Check surrounding pixels
                                let darkNeighbors = 0;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                        const nBrightness = 0.299 * data[nIdx] + 0.587 * data[nIdx + 1] + 0.114 * data[nIdx + 2];
                                        if (nBrightness < threshold - 50) darkNeighbors++;
                                    }
                                }
                                
                                // If mostly surrounded by dark pixels, keep it (likely signature content)
                                // If surrounded by light pixels, make it transparent (likely background)
                                if (darkNeighbors < 2) {
                                    data[idx + 3] = 0;
                                    if (originalAlpha > 0) pixelsChanged++;
                                } else if (darkNeighbors < 4) {
                                    // Partial transparency for edges
                                    const newAlpha = Math.max(100, data[idx + 3] - 50);
                                    if (newAlpha !== originalAlpha) {
                                        data[idx + 3] = newAlpha;
                                        pixelsChanged++;
                                    }
                                }
                            }
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Debug info
                    const debugInfo = `
                        Image: ${canvas.width}x${canvas.height} (${totalPixels} pixels)
                        Threshold: ${threshold}
                        Pixels changed: ${pixelsChanged} (${((pixelsChanged/totalPixels)*100).toFixed(1)}%)
                    `;
                    document.getElementById('debug').innerHTML = debugInfo;
                    
                    resolve(canvas.toDataURL('image/png', 1.0));
                };
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = imageDataUrl;
            });
        }
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                currentImageData = e.target.result;
                document.getElementById('original').src = currentImageData;
                processImage();
            };
            reader.readAsDataURL(file);
        });
        
        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = e.target.value;
            if (currentImageData) {
                processImage();
            }
        });
        
        document.getElementById('removeBackground').addEventListener('change', () => {
            if (currentImageData) {
                processImage();
            }
        });
        
        async function processImage() {
            if (!currentImageData) return;
            
            const shouldRemove = document.getElementById('removeBackground').checked;
            const threshold = parseInt(document.getElementById('threshold').value);
            
            try {
                const processed = await processBackground(currentImageData, shouldRemove, threshold);
                document.getElementById('processed').src = processed;
                
                console.log('Processing complete:', {
                    shouldRemove,
                    threshold,
                    original: currentImageData.substring(0, 50) + '...',
                    processed: processed.substring(0, 50) + '...'
                });
            } catch (error) {
                console.error('Processing failed:', error);
                document.getElementById('debug').innerHTML = 'Error: ' + error.message;
            }
        }
    </script>
</body>
</html>